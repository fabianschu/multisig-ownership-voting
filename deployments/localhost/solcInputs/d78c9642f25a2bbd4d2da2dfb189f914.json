{
  "language": "Solidity",
  "sources": {
    "contracts/Ballot.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./OwnerManager.sol\";\nimport \"./IBPool.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract Ballot is OwnerManager {\n\n    enum ProposalType { addOwner, removeOwner }\n    enum ProposalStatus { closed, open }\n\n    struct Proposal {\n        ProposalType proposalType;\n        address owner;\n        uint votes;\n        ProposalStatus proposalStatus;\n    }\n\n    event ProposalAdded (uint index, uint proposalType, address target);\n\n    modifier onlyStaker() {\n        require(stakes[msg.sender] != 0, \"B2\");\n        _;\n    }\n\n    modifier activeProposal(uint _index) {\n        require(proposals[_index].owner != address(0), \"B3\");\n        require(proposals[_index].proposalStatus == ProposalStatus.open, \"B3\");\n        _;\n    }\n\n    IERC20 internal bPool;\n    uint constant public MAX_INT = type(uint).max;    \n    uint public numberProposals;\n    mapping(address => uint) public stakes;\n    mapping(address => uint[]) public votes;\n    mapping(uint => Proposal) public proposals;\n\n    constructor(address _bPool) {\n        bPool = IERC20(_bPool);\n    }\n\n    /// @dev Allows to stake all liquidity provider (LP) tokens from the balancer pool.\n    ///      Without staking voting/proposing is not possible.\n    ///      This contract must have been approved with the balancer pool first.\n    /// @notice Updates the caller's stakes.\n    function stake() public {\n        uint allowance = bPool.allowance(msg.sender, address(this));\n        require(allowance == MAX_INT, \"B1\");\n\n        uint stakerBalance = bPool.balanceOf(msg.sender);\n        bPool.transferFrom(msg.sender, address(this), stakerBalance);\n        stakes[msg.sender] = stakerBalance;\n    }\n    \n    /// @dev Allows to unstake LP tokens.\n    ///      Triggers removal of outstanding votes to avoid double voting.\n    /// @notice Updates the caller's stakes. Removes caller's votes from open proposals.\n    function unstake() public onlyStaker {\n        bPool.transfer(msg.sender, stakes[msg.sender]);\n        uint[] memory openVotes = votes[msg.sender];\n        for (uint i = 0; i < openVotes.length; i++) {\n            if (proposals[openVotes[i]].proposalStatus == ProposalStatus.open) {\n                proposals[openVotes[i]].votes -= stakes[msg.sender];\n            }\n        }\n        stakes[msg.sender] = 0;\n        votes[msg.sender] = new uint[](0);\n    }\n\n    /// @dev Allows to add a new proposal about adding or removing owner.\n    ///      The proposer automatically votes on her proposal.\n    /// @notice Updates proposals. Updates the total number of proposals.\n    function addProposal(uint _type, address _target) public onlyStaker {\n        require(_target != address(0), \"B4\");\n        Proposal memory proposal = Proposal(\n            ProposalType(_type),\n            _target,\n            0,\n            ProposalStatus.open\n        );\n    \n        emit ProposalAdded(numberProposals, _type, _target);\n        proposals[numberProposals] = proposal;\n        vote(numberProposals);\n        numberProposals++;\n    }\n\n    /// @dev Allows to vote on a proposal.\n    ///      If majority is reached (votes > half of total supply of LP tokens) proposal is executed.\n    /// @notice Updates votes on a proposal. Marks that voter has voted for a proposal (= update to votes)\n    function vote(uint _index) public onlyStaker activeProposal(_index) {\n        require(!hasAlreadyVoted(_index), \"B5\");\n\n        proposals[_index].votes += stakes[msg.sender];\n        if (isMajorityVote(_index)) {\n            executeProposal(_index);\n        } else {\n            votes[msg.sender].push(_index);\n        }\n    }\n\n    /// @dev Checks if voter has already voted on proposal.\n    ///      If majority is reached (votes > half of total supply of LP tokens) proposal is executed.\n    /// @return Returns true if attempted double vote.\n    function hasAlreadyVoted(uint _index) internal view returns(bool) {\n        for (uint i = 0; i < votes[msg.sender].length; i++) {\n            if (votes[msg.sender][i] == _index) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Checks if a majority of LP token holders has voted for proposal.\n    /// @return Returns true if majority is reached.\n    function isMajorityVote(uint _index) public view returns(bool){\n        uint total = bPool.totalSupply();\n        return proposals[_index].votes * 2 > total;\n    }\n\n    /// @dev Adds or removes an owner as specified by the accepted proposal.\n    ///      Is public to enable external triggering of execution.\n    ///      This is important when majority ratios of Liquidity Pool have changed.\n    ///      E.g. a major LP leaves the pool, so that a majority for a proposal is suddenly reached.\n    /// @notice Sets the proposal status to closed.\n    function executeProposal(uint _index) public {\n        require(isMajorityVote(_index), \"B6\");\n\n        uint newSafeThreshold = newMultiSigThreshold(proposals[_index].proposalType);\n        address elected = proposals[_index].owner;\n        if (proposals[_index].proposalType == ProposalType.addOwner) {\n            addOwnerWithThreshold(elected, newSafeThreshold);\n        } else {\n            address[] memory currentOwners = getOwners();\n            address prevOwner = SENTINEL_OWNERS;\n            address owner;\n            for (uint i; i < currentOwners.length; i++) {\n                if (currentOwners[i] == proposals[_index].owner) {\n                    owner = currentOwners[i];\n                    if(i != 0) {\n                        prevOwner = currentOwners[i - 1];\n                    }\n                }\n            }\n            removeOwner(prevOwner, owner, newSafeThreshold);\n        }\n        proposals[_index].proposalStatus = ProposalStatus.closed;\n    }\n\n    /// @dev Calculates the threshold for the multisig contract\n    ///      Makes sure that the threshold is always just above 50%.\n    /// @return The smallest possible majority threshold.\n    function newMultiSigThreshold(ProposalType _proposalType) internal view returns(uint) {\n        uint nextOwnerCount;\n        uint nextThreshold = threshold;\n\n        if (_proposalType == ProposalType.addOwner) {\n            nextOwnerCount = ownerCount + 1;\n            if (threshold * 2 <= nextOwnerCount) {\n                nextThreshold++;\n            }\n        } else if (_proposalType == ProposalType.removeOwner) {\n            nextOwnerCount = ownerCount - 1;\n            if ((threshold - 1) * 2 > nextOwnerCount) {\n                nextThreshold--;\n            }\n        } \n\n        require(nextOwnerCount > 0, \"B7\");\n\n        return nextThreshold; \n    }\n}\n"
    },
    "contracts/OwnerManager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title OwnerManager - Manages a set of owners and a threshold to perform actions.\n/// @author Stefan George - <stefan@gnosis.pm>\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract OwnerManager {\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 internal ownerCount;\n    uint256 internal threshold;\n\n    constructor() {\n        threshold = 1;\n        ownerCount = 1;\n        owners[SENTINEL_OWNERS] = msg.sender;\n        owners[msg.sender] = SENTINEL_OWNERS;\n    }\n\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Adds the owner `owner` to the Safe and updates the threshold to `_threshold`.\n    /// @param owner New owner address.\n    /// @param _threshold New threshold.\n    function addOwnerWithThreshold(address owner, uint256 _threshold) internal {\n        // Owner address cannot be null, the sentinel or the Safe itself.\n        require(owner != address(0) && owner != SENTINEL_OWNERS && owner != address(this), \"GS203\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"GS204\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Removes the owner `owner` from the Safe and updates the threshold to `_threshold`.\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\n    /// @param owner Owner address to be removed.\n    /// @param _threshold New threshold.\n    function removeOwner(\n        address prevOwner,\n        address owner,\n        uint256 _threshold\n    ) internal {\n        // Only allow to remove an owner, if threshold can still be reached.\n        require(ownerCount - 1 >= _threshold, \"GS201\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"GS203\");\n        require(owners[prevOwner] == owner, \"GS205\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /// @dev Allows to update the number of required confirmations by Safe owners.\n    ///      This can only be done via a Safe transaction.\n    /// @notice Changes the threshold of the Safe to `_threshold`.\n    /// @param _threshold New threshold.\n    function changeThreshold(uint256 _threshold) internal {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"GS201\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"GS202\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold() public view returns (uint256) {\n        return threshold;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n    }\n\n    /// @dev Returns array of owners.\n    /// @return Array of Safe owners.\n    function getOwners() public view returns (address[] memory) {\n        address[] memory array = new address[](ownerCount);\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index++;\n        }\n        return array;\n    }\n}\n"
    },
    "contracts/IBPool.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IBPool {\n    function rebind(address token, uint balance, uint denorm) external;\n    function setSwapFee(uint swapFee) external;\n    function setPublicSwap(bool publicSwap) external;\n    function bind(address token, uint balance, uint denorm) external;\n    function unbind(address token) external;\n    function gulp(address token) external;\n    function isBound(address token) external view returns(bool);\n    function getBalance(address token) external view returns (uint);\n    function totalSupply() external view returns (uint);\n    function getSwapFee() external view returns (uint);\n    function isPublicSwap() external view returns (bool);\n    function isFinalized() external view returns (bool);\n    function getNumTokens() external view returns (uint);\n    function getFinalTokens() external view returns (address[] memory tokens);\n    function getNormalizedWeight(address token) external view returns (uint);\n    function getController() external view returns (address);\n    function setController(address manager) external;\n    function finalize() external;\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint spotPrice);\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint spotPrice);\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n    function getDenormalizedWeight(address token) external view returns (uint);\n    function getTotalDenormalizedWeight() external view returns (uint);\n    // solhint-disable-next-line func-name-mixedcase\n    function EXIT_FEE() external view returns (uint);\n \n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        external pure\n        returns (uint tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        external pure\n        returns (uint poolAmountIn);\n\n    function getCurrentTokens()\n        external view\n        returns (address[] memory tokens);\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    )\n        external\n        returns (uint tokenAmountOut, uint spotPriceAfter);\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    )\n        external\n        returns (uint tokenAmountIn, uint spotPriceAfter);\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n        external\n        returns (uint poolAmountOut);\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\n        external\n        returns (uint tokenAmountIn);\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\n        external\n        returns (uint tokenAmountOut);\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\n        external\n        returns (uint poolAmountIn);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address whom) external view returns (uint);\n    function allowance(address src, address dst) external view returns (uint);\n\n    function approve(address dst, uint amt) external returns (bool);\n    function transfer(address dst, uint amt) external returns (bool);\n    function transferFrom(\n        address src, address dst, uint amt\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}